

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Structure from Motion (SfM) &mdash; Theia Vision Library</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Theia Vision Library" href="index.html"/>
        <link rel="up" title="API Reference" href="api.html"/>
        <link rel="next" title="Applications" href="applications.html"/>
        <link rel="prev" title="Math" href="math.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="index.html" class="fa fa-home"> Theia Vision Library</a>
        
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="building.html">Building Theia Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="building.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building">Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#customizing-the-build">Customizing the build</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="api.html">API Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="image.html">Image</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="ransac.html">Ransac</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html">Pose and Resectioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html">Math</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Structure from Motion (SfM)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="applications.html">Applications</a><ul>
<li class="toctree-l2"><a class="reference internal" href="applications.html#features">Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="applications.html#reconstructions">Reconstructions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contributions.html">Contributing to Theia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#style-and-testing">Style and Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#cmake">CMake</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#developing-for-theia">Developing for Theia</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#submitting-a-change-to-theia">Submitting a change to Theia</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="releases.html">Releases</a><ul>
<li class="toctree-l2"><a class="reference internal" href="releases.html#id1">0.1.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a><ul>
<li class="toctree-l2"><a class="reference internal" href="license.html#citation">Citation</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Theia Vision Library</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="api.html">API Reference</a> &raquo;</li>
      
    <li>Structure from Motion (SfM)</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="structure-from-motion-sfm">
<span id="documentation-sfm"></span><h1>Structure from Motion (SfM)<a class="headerlink" href="#structure-from-motion-sfm" title="Permalink to this headline">¶</a></h1>
<p>Theia has a full Structure-from-Motion pipeline that is extremely efficient. Our
overall pipeline consists of several steps. First, we extract features (SIFT is
the default). Then, we perform two-view matching and geometric verification to
obtain relative poses between image pairs and create a <a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a>. Next,
we perform global pose estimation with gloabl SfM. Global SfM is different from
incremental SfM in that it considers the entire view graph at the same time
instead of incrementally adding more and more images to the
<a class="reference internal" href="#Reconstruction" title="Reconstruction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Reconstruction</span></tt></a>. Global SfM methods have been proven to be very fast
with comparable or better accuracy to incremental SfM approaches (See
<a class="reference internal" href="bibliography.html#jiangiccv" id="id1">[JiangICCV]</a>, <a class="reference internal" href="bibliography.html#mouloniccv" id="id2">[MoulonICCV]</a>, <a class="reference internal" href="bibliography.html#wilsoneccv" id="id3">[WilsonECCV]</a>), and they are much more readily
parallelized. After we have obtained camera poses, we perform triangulation and
<tt class="xref cpp cpp-class docutils literal"><span class="pre">BundleAdjustment</span></tt> to obtain a valid 3D reconstruction consisting of
cameras and 3D points.</p>
<p>The first step towards creating a reconstruction is to determine images which
view the same objects. To do this, we must create a <a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a>.</p>
<blockquote>
<div><ol class="arabic simple">
<li>Extract features in images.</li>
<li>Match features to obtain image correspondences.</li>
<li>Estimate camera poses from two-view matches and geometries.</li>
</ol>
</div></blockquote>
<p>INSERT FIGURE HERE!!!</p>
<p>#1. and #2. have been covered in other sections, so we will focus on creating a
reconstruction from two-view matches and geometry. First, we will describe the
fundamental elements of our reconstruction.</p>
<div class="section" id="reconstruction">
<h2>Reconstruction<a class="headerlink" href="#reconstruction" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Reconstruction">
<em class="property">class </em><tt class="descname">Reconstruction</tt><a class="headerlink" href="#Reconstruction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>INSERT FIGURE HERE</p>
<p>At the core of our SfM pipeline is an SfM <a class="reference internal" href="#Reconstruction" title="Reconstruction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Reconstruction</span></tt></a>. A
<a class="reference internal" href="#Reconstruction" title="Reconstruction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Reconstruction</span></tt></a> is the representation of a 3D reconstuction consisting
of a set of unique <tt class="xref cpp cpp-class docutils literal"><span class="pre">Views</span></tt> and <tt class="xref cpp cpp-class docutils literal"><span class="pre">Tracks</span></tt>. More importantly, the
<a class="reference internal" href="#Reconstruction" title="Reconstruction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Reconstruction</span></tt></a> class contains visibility information relating all of
the Views and Tracks to each other. We identify each <tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt> uniquely
based on the name (a string). A good name for the view is the filename of the
image that corresponds to the <tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt></p>
<p>When creating an SfM reconstruction, you should add each <tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt> and
<tt class="xref cpp cpp-class docutils literal"><span class="pre">Track</span></tt> through the <a class="reference internal" href="#Reconstruction" title="Reconstruction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Reconstruction</span></tt></a> object. This will ensure that
visibility information (such as which Tracks are observed a given View and which
Views see a given Track) stays accurate. Views and Tracks are given a unique ID
when added to the <a class="reference internal" href="#Reconstruction" title="Reconstruction"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Reconstruction</span></tt></a> to help make use of these structures
lightweight and efficient.</p>
<dl class="function">
<dt id="AddView__ssCR">
ViewId <tt class="descname">AddView</tt><big>(</big>const std::string&amp; <em>view_name</em><big>)</big><a class="headerlink" href="#AddView__ssCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a view to the reconstruction with the default initialization. The ViewId
returned is guaranteed to be unique or will be kInvalidViewId if the method
fails. Each view is uniquely identified by the view name (a good view name could
be the filename of the image).</p>
</dd></dl>

<dl class="function">
<dt id="RemoveView__ViewIdC">
bool <tt class="descname">RemoveView</tt><big>(</big>const ViewId <em>view_id</em><big>)</big><a class="headerlink" href="#RemoveView__ViewIdC" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the view from the reconstruction and removes all references to the view in
the tracks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Any tracks that have length 0 after the view is removed will also be removed.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="NumViewsC">
int <tt class="descname">NumViews</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#NumViewsC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="NumTracksC">
int <tt class="descname">NumTracks</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#NumTracksC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="View__ViewIdCC">
const View* <tt class="descname">View</tt><big>(</big>const ViewId <em>view_id</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#View__ViewIdCC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="MutableView__ViewIdC">
View* <tt class="descname">MutableView</tt><big>(</big>const ViewId <em>view_id</em><big>)</big><a class="headerlink" href="#MutableView__ViewIdC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the View or a nullptr if the track does not exist.</p>
</dd></dl>

<dl class="function">
<dt id="ViewIdsC">
std::vector&lt;ViewId&gt; <tt class="descname">ViewIds</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#ViewIdsC" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all ViewIds in the reconstruction.</p>
</dd></dl>

<dl class="function">
<dt id="ViewIdFromName__ssCRC">
ViewId <tt class="descname">ViewIdFromName</tt><big>(</big>const std::string&amp; <em>view_name</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#ViewIdFromName__ssCRC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns to ViewId of the view name, or kInvalidViewId if the view does not
exist.</p>
</dd></dl>

<dl class="function">
<dt id="AddTrack__std::vector:std::pair:ViewId.Feature::CR">
TrackId <tt class="descname">AddTrack</tt><big>(</big>const std::vector&lt;std::pair&lt;ViewId, Feature&gt;&gt;&amp; <em>track</em><big>)</big><a class="headerlink" href="#AddTrack__std::vector:std::pair:ViewId.Feature::CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a track to the reconstruction with all of its features across views that observe
this track. Each pair contains a feature and the corresponding View name
(i.e., the string) that observes the feature. A new View will be created if
a View with the view name does not already exist. This method will not
estimate the position of the track. The TrackId returned will be unique or
will be kInvalidTrackId if the method fails.</p>
</dd></dl>

<dl class="function">
<dt id="RemoveTrack__TrackIdC">
bool <tt class="descname">RemoveTrack</tt><big>(</big>const TrackId <em>track_id</em><big>)</big><a class="headerlink" href="#RemoveTrack__TrackIdC" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the track from the reconstruction and from any Views that observe this
track. Returns true on success and false on failure (e.g., the track does
not exist).</p>
</dd></dl>

<dl class="function">
<dt id="Track__TrackIdCC">
const Track* <tt class="descname">Track</tt><big>(</big>const TrackId <em>track_id</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Track__TrackIdCC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="MutableTrack__TrackIdC">
Track* <tt class="descname">MutableTrack</tt><big>(</big>const TrackId <em>track_id</em><big>)</big><a class="headerlink" href="#MutableTrack__TrackIdC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Track or a nullptr if the track does not exist.</p>
</dd></dl>

<dl class="function">
<dt id="TrackIdsC">
std::vector&lt;TrackId&gt; <tt class="descname">TrackIds</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#TrackIdsC" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all TrackIds in the reconstruction.</p>
</dd></dl>

</div>
<div class="section" id="viewgraph">
<h2>ViewGraph<a class="headerlink" href="#viewgraph" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ViewGraph">
<em class="property">class </em><tt class="descname">ViewGraph</tt><a class="headerlink" href="#ViewGraph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>INSERT FIGURE HERE</p>
<p>A <a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a> is a basic SfM construct that is created from two-view
matching information. Any pair of views that have a view correlation form an
edge in the <a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a> such that the nodes in the graph are
<tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt> that are connected by <a class="reference internal" href="#TwoViewInfo" title="TwoViewInfo"><tt class="xref cpp cpp-class docutils literal"><span class="pre">TwoViewInfo</span></tt></a> objects that contain
information about the relative pose between the Views as well as matching
information.</p>
<p>Once you have a set of views and match information, you can add them to the view graph:</p>
<div class="code c++ highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">View</span><span class="o">&gt;</span> <span class="n">views</span><span class="p">;</span>
<span class="c1">// Match all views in the set.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ViewIdPair</span><span class="p">,</span> <span class="n">TwoViewInfo</span><span class="o">&gt;</span> <span class="n">view_pair_matches</span><span class="p">;</span>

<span class="n">ViewGraph</span> <span class="n">view_graph</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">view_pair</span> <span class="o">:</span> <span class="n">view_pair_matches</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">ViewIdPair</span><span class="o">&amp;</span> <span class="n">view_id_pair</span> <span class="o">=</span> <span class="n">view_pair</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">TwoViewInfo</span><span class="o">&amp;</span> <span class="n">two_view_info</span> <span class="o">=</span> <span class="n">view_pair</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="c1">// Only add view pairs to the view graph if they have strong visual coherence.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">two_view_info</span><span class="p">.</span><span class="n">num_matched_features</span> <span class="o">&gt;</span> <span class="n">min_num_matched_features</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">view_graph</span><span class="p">.</span><span class="n">AddEdge</span><span class="p">(</span><span class="n">views</span><span class="p">[</span><span class="n">view_id_pair</span><span class="p">.</span><span class="n">first</span><span class="p">],</span>
                       <span class="n">views</span><span class="p">[</span><span class="n">view_id_pair</span><span class="p">.</span><span class="n">second</span><span class="p">],</span>
                       <span class="n">two_view_info</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Process and/or manipulate the view graph.</span>
</pre></div>
</div>
<p>The edge values are especially useful for one-shot SfM where the relative poses
are heavily exploited for computing the final poses. Without a proper
<a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a>, one-shot SfM would not be possible.</p>
</div>
<div class="section" id="views-and-tracks">
<h2>Views and Tracks<a class="headerlink" href="#views-and-tracks" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="View">
<em class="property">class </em><tt class="descname">View</tt><a class="headerlink" href="#View" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>At the heart of our SfM framework is the <tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt> class which represents
everything about an image that we want to reconstruct. It contains information
about features from the image, camera pose information, and EXIF
information. Views make up our basic visiblity constraints and are a fundamental
part of the SfM pipeline.</p>
<dl class="class">
<dt id="Track">
<em class="property">class </em><tt class="descname">Track</tt><a class="headerlink" href="#Track" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A <tt class="xref cpp cpp-class docutils literal"><span class="pre">Track</span></tt> represents a feature that has been matached over potentially
many images. When a feature appears in multiple images it typically means that
the features correspond to the same 3D point. These 3D points are useful
constraints in SfM reconstruction, as they represent the &#8220;structure&#8221; in
&#8220;Structure-from-Motion&#8221; and help to build a point cloud for our reconstruction.</p>
</div>
<div class="section" id="twoviewinfo">
<h2>TwoViewInfo<a class="headerlink" href="#twoviewinfo" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="TwoViewInfo">
<em class="property">class </em><tt class="descname">TwoViewInfo</tt><a class="headerlink" href="#TwoViewInfo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>After image matching is performed we can create a <a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a> that
explains the relative pose information between two images that have been
matched. The <a class="reference internal" href="#TwoViewInfo" title="TwoViewInfo"><tt class="xref cpp cpp-class docutils literal"><span class="pre">TwoViewInfo</span></tt></a> struct is specified as:</p>
<div class="code c++ highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">TwoViewInfo</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">focal_length_1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">focal_length_2</span><span class="p">;</span>

  <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">position_2</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">rotation_2</span><span class="p">;</span>

  <span class="c1">// Number of features that were matched and geometrically verified betwen the</span>
  <span class="c1">// images.</span>
  <span class="kt">int</span> <span class="n">num_verified_matches</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This information serves the purpose of an edge in the view graph that describes
visibility information between all views. The relative poses here are used to
estimate global poses for the cameras.</p>
</div>
<div class="section" id="camera">
<h2>Camera<a class="headerlink" href="#camera" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Camera">
<em class="property">class </em><tt class="descname">Camera</tt><a class="headerlink" href="#Camera" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Each <tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt> contains a <a class="reference internal" href="#Camera" title="Camera"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Camera</span></tt></a> object that contains intrinsic and
extrinsic information about the camera that observed the scene. Theia has an
efficient, compact <a class="reference internal" href="#Camera" title="Camera"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Camera</span></tt></a> class that abstracts away common image
operations. This greatly relieves the pain of manually dealing with calibration
and geometric transformations of images. We represent camera intrinsics such
that the calibration matrix is:</p>
<div class="math">
\[\begin{split}K = \left[\begin{matrix}f &amp; s &amp; p_x \\ 0 &amp; f * a &amp; p_y \\ 0 &amp; 0 &amp; 1 \end{matrix} \right]\end{split}\]</div>
<p>where <span class="math">\(f\)</span> is the focal length (in pixels), <span class="math">\(s\)</span> is the skew,
<span class="math">\(a\)</span> is the aspect ratio and <span class="math">\(p\)</span> is the principle point of the
camera. All of these intrinsics may be accessed with getter and setter methods,
e.g., <tt class="code docutils literal"><span class="pre">double</span> <span class="pre">GetFocalLenth()</span></tt> or <tt class="code docutils literal"><span class="pre">void</span> <span class="pre">SetFocalLength(const</span> <span class="pre">double</span>
<span class="pre">focal_length)</span></tt>. Note that we do additionally allow for up to two radial
distortion parameters, but these are not part of the calibration matrix so they
must be set or retrieved separately from the corresponding getter/setter
methods.</p>
<p>We store the camera pose information as the transformation which maps world
coordinates into camera coordinates. Our rotation is stored internally as an
<cite>SO(3)</cite> rotation, which makes optimization with <tt class="xref cpp cpp-class docutils literal"><span class="pre">BundleAdjustment</span></tt> more
effective since the value is always a valid rotation (unlike e.g., Quaternions
that must be normalized after each optimization step). However, for convenience
we provide an interface to retrieve the rotation as a rotation matrix as
well. Further, we store the camera position as opposed to the translation.</p>
<p>The convenience of this camera class is clear with the common example of 3D
point reprojection.</p>
<div class="code c++ highlight-c++"><div class="highlight"><pre><span class="c1">// Open an image and obtain camera parameters.</span>
<span class="n">FloatImage</span> <span class="nf">image</span><span class="p">(</span><span class="s">&quot;my_image.jpg&quot;</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">focal_length</span><span class="p">;</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">FocalLengthPixels</span><span class="p">(</span><span class="o">&amp;</span><span class="n">focal_length</span><span class="p">));</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">radial_distortion1</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">radial_distortion2</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>
<span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>
<span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">position</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>

<span class="c1">// Set up the camera.</span>
<span class="n">Camera</span> <span class="n">camera</span><span class="p">;</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetOrientationFromRotationMatrix</span><span class="p">(</span><span class="n">rotation</span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetPosition</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetFocalLength</span><span class="p">(</span><span class="n">focal_length</span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetPrincipalPoint</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetRadialDistortion</span><span class="p">(</span><span class="n">radial_distortion1</span><span class="p">,</span> <span class="n">radial_distortion2</span><span class="p">);</span>

<span class="c1">// Obtain a homogeneous 3D point</span>
<span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4d</span> <span class="n">homogeneous_point3d</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>

<span class="c1">// Reproject the 3D point to a pixel.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span> <span class="n">reprojection_pixel</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">camera</span><span class="p">.</span><span class="n">ProjectPoint</span><span class="p">(</span><span class="n">homogeneous_point3d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pixel</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Point was behind the camera!&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Homogeneous 3D point: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">homogeneous_point3d</span>
          <span class="o">&lt;&lt;</span> <span class="s">&quot; reprojected to the pixel value of &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">reprojection_pixel</span><span class="p">;</span>
</pre></div>
</div>
<p>Point projection can be a tricky function when considering the camera intrinsics
and extrinsics. Theia takes care of this projection (including radial
distortion) in a simple and efficient manner.</p>
<p>In addition to typical getter/setter methods for the camera parameters, the
<a class="reference internal" href="#Camera" title="Camera"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Camera</span></tt></a> class also defines several helper functions:.</p>
<dl class="function">
<dt id="InitializeFromProjectionMatrix__iC.iC.Matrix3x4dC">
bool <tt class="descname">InitializeFromProjectionMatrix</tt><big>(</big>const int <em>image_width</em>, const int <em>image_height</em>, const Matrix3x4d <em>projection_matrix</em><big>)</big><a class="headerlink" href="#InitializeFromProjectionMatrix__iC.iC.Matrix3x4dC" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the camera intrinsic and extrinsic parameters from the
projection matrix by decomposing the matrix with a RQ decomposition.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The projection matrix does not contain information about radial
distortion, so those parameters will need to be set separately.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="GetProjectionMatrix__Matrix3x4dPC">
void <tt class="descname">GetProjectionMatrix</tt><big>(</big>Matrix3x4d* <em>pmatrix</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#GetProjectionMatrix__Matrix3x4dPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the projection matrix. Does not include radial distortion.</p>
</dd></dl>

<dl class="function">
<dt id="GetCalibrationMatrix__Eigen::Matrix3dPC">
void <tt class="descname">GetCalibrationMatrix</tt><big>(</big>Eigen::Matrix3d* <em>kmatrix</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#GetCalibrationMatrix__Eigen::Matrix3dPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the calibration matrix in the form specified above.</p>
</dd></dl>

<dl class="function">
<dt id="PixelToUnitDepthRay__Eigen::Vector2dCRC">
Eigen::Vector3d <tt class="descname">PixelToUnitDepthRay</tt><big>(</big>const Eigen::Vector2d&amp; <em>pixel</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#PixelToUnitDepthRay__Eigen::Vector2dCRC" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the pixel point to a ray in 3D space such that the origin of the
ray is at the camera center and the direction is the pixel direction rotated
according to the camera orientation in 3D space. The returned vector is not
unit length.</p>
</dd></dl>

</div>
<div class="section" id="global-sfm-pipeline">
<h2>Global SfM Pipeline<a class="headerlink" href="#global-sfm-pipeline" title="Permalink to this headline">¶</a></h2>
<p>The global SfM pipelines in Theia follow a general procedure of filtering
outliers and estimating camera poses or structure. Removing outliers can help
increase performance dramatically for global SfM, though robust estimation
methods are still required to obtain good results. The general pipeline is as
follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Create the intial view graph from 2-view matches and <a class="reference internal" href="#TwoViewInfo" title="TwoViewInfo"><tt class="xref cpp cpp-class docutils literal"><span class="pre">TwoViewInfo</span></tt></a>
that describes the relative pose between matched images.</li>
<li>Filter initial view graph and remove outlier 2-view matches.</li>
<li>Calibrate internal parameters of all cameras (either from EXIF or another
calibration method).</li>
<li>Estimate global orientations of each camera.</li>
<li>Filter the view graph: remove any TwoViewInfos where the relative rotation
does not agree with the estimated global rotations.</li>
<li>Refine the relative translation estimation to account for the estimated
global rotations.</li>
<li>Filter any bad <a class="reference internal" href="#TwoViewInfo" title="TwoViewInfo"><tt class="xref cpp cpp-class docutils literal"><span class="pre">TwoViewInfo</span></tt></a> based on the relative translations.</li>
<li>Estimate the global positions of all cameras from the estimated rotations
and <a class="reference internal" href="#TwoViewInfo" title="TwoViewInfo"><tt class="xref cpp cpp-class docutils literal"><span class="pre">TwoViewInfo</span></tt></a>.</li>
<li>Estimate 3D points.</li>
<li>Bundle adjust the reconstruction.</li>
<li>(Optional) Attempt to estimate any remaining 3D points and bundle adjust again.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="estimating-global-rotations">
<h2>Estimating Global Rotations<a class="headerlink" href="#estimating-global-rotations" title="Permalink to this headline">¶</a></h2>
<p>Theia estimates the global rotations of cameras robustly using a nonlinear
optimization. Using the relative rotations obtained from all
<a class="reference internal" href="#TwoViewInfo" title="TwoViewInfo"><tt class="xref cpp cpp-class docutils literal"><span class="pre">TwoViewInfo</span></tt></a>, we enforce the constraint that</p>
<blockquote>
<div><span class="math">\(R_{i,j} = R_j * R_i^T\)</span></div></blockquote>
<p>We use the angle-axis representation of rotations to ensure that proper
rotations are formed. All pairwise constraints are put into a nonlinear
optimization with a robust loss function and the global orienations are
computed. The optimization usually converges within just a few iterations and
provides a very accurate result. The nonlinear optimization is initialized by
forming a random spanning tree of the view graph and walking along the edges.</p>
</div>
<div class="section" id="estimating-global-positions">
<h2>Estimating Global Positions<a class="headerlink" href="#estimating-global-positions" title="Permalink to this headline">¶</a></h2>
<p>Positions of cameras may be estimated simultaneously after the rotations are
known. We use a nonlinear optimization to estimate camera positions based. Given
pairwise relative translations from <a class="reference internal" href="#TwoViewInfo" title="TwoViewInfo"><tt class="xref cpp cpp-class docutils literal"><span class="pre">TwoViewInfo</span></tt></a> and the estimated
rotation, the constraint</p>
<blockquote>
<div><div class="math">
\[R_i * \dfrac{c_j - c_i}{||c_j - c_i||} = t_{i,j}\]</div>
</div></blockquote>
</div>
<div class="section" id="triangulation">
<h2>Triangulation<a class="headerlink" href="#triangulation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Triangulation in structure from motion calculates the 3D position of an image
coordinate that has been tracked through several, if not many, images.</p>
<dl class="function">
<dt id="Triangulate__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP">
bool <tt class="descname">Triangulate</tt><big>(</big>const Matrix3x4d&amp; <em>pose1</em>, const Matrix3x4d&amp; <em>pose2</em>, const Eigen::Vector2d&amp; <em>point1</em>, const Eigen::Vector2d&amp; <em>point2</em>, Eigen::Vector4d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#Triangulate__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP" title="Permalink to this definition">¶</a></dt>
<dd><p>2-view triangulation using the method described in <a class="reference internal" href="bibliography.html#lindstrom" id="id4">[Lindstrom]</a>. This method
is optimal in an L2 sense such that the reprojection errors are minimized
while enforcing the epipolar constraint between the two
cameras. Additionally, it basically the same speed as the
<a class="reference internal" href="#TriangulateDLT__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP" title="TriangulateDLT"><tt class="xref cpp cpp-func docutils literal"><span class="pre">TriangulateDLT()</span></tt></a> method.</p>
<p>The poses are the (potentially calibrated) poses of the two cameras, and the
points are the 2D image points of the matched features that will be used to
triangulate the 3D point. On successful triangulation, <tt class="docutils literal"><span class="pre">true</span></tt> is
returned. The homogeneous 3d point is output so that it may be known if the
point is at infinity.</p>
</dd></dl>

<dl class="function">
<dt id="TriangulateDLT__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP">
bool <tt class="descname">TriangulateDLT</tt><big>(</big>const Matrix3x4d&amp; <em>pose1</em>, const Matrix3x4d&amp; <em>pose2</em>, const Eigen::Vector2d&amp; <em>point1</em>, const Eigen::Vector2d&amp; <em>point2</em>, Eigen::Vector4d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateDLT__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP" title="Permalink to this definition">¶</a></dt>
<dd><p>The DLT triangulation method of <a class="reference internal" href="bibliography.html#hartleyzisserman" id="id5">[HartleyZisserman]</a>.</p>
</dd></dl>

<dl class="function">
<dt id="TriangulateMidpoint__Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector4dP">
bool <tt class="descname">TriangulateMidpoint</tt><big>(</big>const Eigen::Vector3d&amp; <em>origin1</em>, const Eigen::Vector3d&amp; <em>ray_direction1</em>, const Eigen::Vector3d&amp; <em>origin2</em>, const Eigen::Vector3d&amp; <em>ray_direction2</em>, Eigen::Vector4d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateMidpoint__Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector4dP" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform triangulation by determining the closest point between the two
rays. In this case, the ray origins are the camera positions and the
directions are the (unit-norm) ray directions of the features in 3D
space. This method is known to be suboptimal at minimizing the reprojection
error, but is approximately 10x faster than the other 2-view triangulation
methods.</p>
</dd></dl>

<dl class="function">
<dt id="TriangulateNViewSVD__std::vector:Matrix3x4d:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP">
bool <tt class="descname">TriangulateNViewSVD</tt><big>(</big>const std::vector&lt;Matrix3x4d&gt;&amp; <em>poses</em>, const std::vector&lt;Eigen::Vector2d&gt;&amp; <em>points</em>, Eigen::Vector3d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateNViewSVD__std::vector:Matrix3x4d:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TriangulateNView__std::vector:Matrix3x4d:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP">
bool <tt class="descname">TriangulateNView</tt><big>(</big>const std::vector&lt;Matrix3x4d&gt;&amp; <em>poses</em>, const std::vector&lt;Eigen::Vector2d&gt;&amp; <em>points</em>, Eigen::Vector3d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateNView__std::vector:Matrix3x4d:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP" title="Permalink to this definition">¶</a></dt>
<dd><p>We provide two N-view triangluation methods that minimizes an algebraic
approximation of the geometric error. The first is the classic SVD method
presented in <a class="reference internal" href="bibliography.html#hartleyzisserman" id="id6">[HartleyZisserman]</a>. The second is a custom algebraic
minimization. Note that we can derive an algebraic constraint where we note
that the unit ray of an image observation can be stretched by depth
<span class="math">\(\alpha\)</span> to meet the world point <span class="math">\(X\)</span> for each of the <span class="math">\(n\)</span>
observations:</p>
<div class="math">
\[\alpha_i \bar{x_i} = P_i X,\]</div>
<p>for images <span class="math">\(i=1,\ldots,n\)</span>. This equation can be effectively rewritten as:</p>
<div class="math">
\[\alpha_i = \bar{x_i}^\top P_i X,\]</div>
<p>which can be substituted into our original constraint such that:</p>
<div class="math">
\[\bar{x_i} \bar{x_i}^\top P_i X = P_i X\]</div>
<div class="math">
\[0 = (P_i - \bar{x_i} \bar{x_i}^\top P_i) X\]</div>
<p>We can then stack this constraint for each observation, leading to the linear
least squares problem:</p>
<div class="math">
\[\begin{split}\begin{bmatrix} (P_1 - \bar{x_1} \bar{x_1}^\top P_1) \\ \vdots \\ (P_n - \bar{x_n} \bar{x_n}^\top P_n) \end{bmatrix} X = \textbf{0}\end{split}\]</div>
<p>This system of equations is of the form <span class="math">\(AX=0\)</span> which can be solved by
extracting the right nullspace of <span class="math">\(A\)</span>. The right nullspace of <span class="math">\(A\)</span>
can be extracted efficiently by noting that it is equivalent to the nullspace
of <span class="math">\(A^\top A\)</span>, which is a 4x4 matrix.</p>
</dd></dl>

</div></blockquote>
</div>
<div class="section" id="bundle-adjustment">
<h2>Bundle Adjustment<a class="headerlink" href="#bundle-adjustment" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Docmentation coming soon...</p>
</div>
</div>
<div class="section" id="similarity-transformation">
<h2>Similarity Transformation<a class="headerlink" href="#similarity-transformation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="function">
<dt id="AlignPointCloudsICP__iC.doubleCA.doubleCA.doubleA.doubleA">
void <tt class="descname">AlignPointCloudsICP</tt><big>(</big>const int <em>num_points</em>, const double <em>left</em>[], const double <em>right</em>[], double <em>rotation</em>[3 * 3], double <em>translation</em>[3]<big>)</big><a class="headerlink" href="#AlignPointCloudsICP__iC.doubleCA.doubleCA.doubleA.doubleA" title="Permalink to this definition">¶</a></dt>
<dd><p>We implement ICP for point clouds. We use Besl-McKay registration to align
point clouds. We use SVD decomposition to find the rotation, as this is much
more likely to find the global minimum as compared to traditional ICP, which
is only guaranteed to find a local minimum. Our goal is to find the
transformation from the left to the right coordinate system. We assume that
the left and right reconstructions have the same number of points, and that the
points are aligned by correspondence (i.e. left[i] corresponds to right[i]).</p>
</dd></dl>

<dl class="function">
<dt id="AlignPointCloudsUmeyama__iC.doubleCA.doubleCA.doubleA.doubleA.doubleP">
void <tt class="descname">AlignPointCloudsUmeyama</tt><big>(</big>const int <em>num_points</em>, const double <em>left</em>[], const double <em>right</em>[], double <em>rotation</em>[3 * 3], double <em>translation</em>[3], double* <em>scale</em><big>)</big><a class="headerlink" href="#AlignPointCloudsUmeyama__iC.doubleCA.doubleCA.doubleA.doubleA.doubleP" title="Permalink to this definition">¶</a></dt>
<dd><p>This function estimates the 3D similiarty transformation using the least
squares method of <a class="reference internal" href="bibliography.html#umeyama" id="id7">[Umeyama]</a>. The returned rotation, translation, and scale
align the left points to the right such that <span class="math">\(Right = s * R * Left +
t\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="GdlsSimilarityTransform__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Quaterniond:P.std::vector:Eigen::Vector3d:P.std::vector:double:P">
void <tt class="descname">GdlsSimilarityTransform</tt><big>(</big>const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>ray_origin</em>, const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>ray_direction</em>, const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>world_point</em>, std::vector&lt;Eigen::Quaterniond&gt;* <em>solution_rotation</em>, std::vector&lt;Eigen::Vector3d&gt;* <em>solution_translation</em>, std::vector&lt;double&gt;* <em>solution_scale</em><big>)</big><a class="headerlink" href="#GdlsSimilarityTransform__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Quaterniond:P.std::vector:Eigen::Vector3d:P.std::vector:double:P" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the solution to the generalized pose and scale problem based on the
paper &#8220;gDLS: A Scalable Solution to the Generalized Pose and Scale Problem&#8221;
by Sweeney et. al. <a class="reference internal" href="bibliography.html#sweeneygdls" id="id8">[SweeneyGDLS]</a>. Given image rays from one coordinate
system that correspond to 3D points in another coordinate system, this
function computes the rotation, translation, and scale that will align the
rays with the 3D points. This is used for applications such as loop closure
in SLAM and SfM. This method is extremely scalable and highly accurate
because the cost function that is minimized is independent of the number of
points. Theoretically, up to 27 solutions may be returned, but in practice
only 4 real solutions arise and in almost all cases where n &gt;= 6 there is
only one solution which places the observed points in front of the
camera. The rotation, translation, and scale are defined such that:
<span class="math">\(sp_i + \alpha_i d_i = RX_i + t\)</span> where the observed image ray has an
origin at <span class="math">\(p_i\)</span> in the unit direction <span class="math">\(d_i\)</span> corresponding to 3D
point <span class="math">\(X_i\)</span>.</p>
<p><tt class="docutils literal"><span class="pre">ray_origin</span></tt>: the origin (i.e., camera center) of the image ray used in
the 2D-3D correspondence.</p>
<p><tt class="docutils literal"><span class="pre">ray_direction</span></tt>: Normalized image rays corresponding to reconstruction
points. Must contain at least 4 points.</p>
<p><tt class="docutils literal"><span class="pre">world_point</span></tt>: 3D location of features. Must correspond to the image_ray
of the same index. Must contain the same number of points as image_ray, and
at least 4.</p>
<p><tt class="docutils literal"><span class="pre">solution_rotation</span></tt>: the rotation quaternion of the candidate solutions</p>
<p><tt class="docutils literal"><span class="pre">solution_translation</span></tt>: the translation of the candidate solutions</p>
<p><tt class="docutils literal"><span class="pre">solution_scale</span></tt>: the scale of the candidate solutions</p>
</dd></dl>

</div></blockquote>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="applications.html" class="btn btn-neutral float-right" title="Applications">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="math.html" class="btn btn-neutral" title="Math"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Chris Sweeney.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
  MathJax.Hub.Config({
    "HTML-CSS": {
      availableFonts: ["TeX"]
    }
  });
</script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 
<!-- Google Analytics Code -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46196711-1', 'ucsb.edu');
  ga('send', 'pageview');

</script>


</body>
</html>